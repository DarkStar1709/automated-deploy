import fs from "fs-extra";
import path from "path";
import chalk from "chalk";
import ejs from "ejs";
import logger from "../utils/logger.js"; // if you're using ESModules
import { GoogleGenerativeAI } from "@google/generative-ai";

// Setup Gemini
const gemini = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Framework Detection
export const detectFramework = async (projectPath) => {
  if (fs.existsSync(path.join(projectPath, "package.json"))) {
    const pkg = JSON.parse(fs.readFileSync(path.join(projectPath, "package.json")));
    if (pkg.dependencies?.express || pkg.devDependencies?.express) {
      return "node-express";
    }
  }

  if (fs.existsSync(path.join(projectPath, "requirements.txt"))) {
    const content = fs.readFileSync(path.join(projectPath, "requirements.txt"), "utf-8");
    if (content.toLowerCase().includes("django")) {
      return "python-django";
    }
  }

  if (fs.existsSync(path.join(projectPath, "go.mod"))) {
    return "go";
  }

  if (fs.existsSync(path.join(projectPath, "pom.xml"))) {
    return "java-springboot";
  }

  return null;
};

// Prompt templates
const promptMap = {
  "node-express": `
You are a DevOps assistant. Generate a production-ready Dockerfile for a Node.js + Express app.
Requirements:
- Use 'node:18' base image
- Install dependencies with 'npm install'
- Expose port 3000
- Start the app with 'npm start'
`,
  "python-django": `
Generate a Dockerfile for a Django project.
Requirements:
- Use python:3.10
- Install dependencies from requirements.txt
- Use gunicorn for production
- Collect static files
- Expose port 8000
`,
  "go": `
Create a multistage Dockerfile for a Go microservice with go.mod.
Requirements:
- Build the binary in /app/main
- Expose port 8080
- Use a minimal final image
`,
  "java-springboot": `
Generate a Dockerfile for a Java Spring Boot app.
Requirements:
- Build the app using Maven or Gradle
- Copy final JAR to /app/app.jar
- Use OpenJDK base image
- Expose port 8080
- Start with 'java -jar /app/app.jar'
`
};

// Generate Dockerfile from Gemini
const generateDockerfile = async (framework) => {
  try {
    const model = gemini.getGenerativeModel({ model: "gemini-pro" });
    const prompt = promptMap[framework];
    const result = await model.generateContent(prompt);
    const response = await result.response;
    return response.text();
  } catch (error) {
    logger.error("Gemini API Error:", error.message);
    return null;
  }
};

// Fallback from template
const fallbackFromTemplate = async (framework, projectPath) => {
  const templatePath = path.resolve(`templates/Dockerfile-${framework}.ejs`);
  const outputPath = path.join(projectPath, "Dockerfile");

  if (fs.existsSync(templatePath)) {
    const rendered = await ejs.renderFile(templatePath, {}, {});
    await fs.writeFile(outputPath, rendered);
    logger.warn("‚ö†Ô∏è  Fallback Dockerfile template used.");
    logger.fileOperation("create", outputPath);
  } else {
    console.log(chalk.red(`No fallback template found for ${framework}`));
  }
};

// Main entry
const analyzeProject = async (projectPath, useAI = true) => {
  logger.title("üîç Analyzing project...");

  const framework = await detectFramework(projectPath);
  if (!framework) {
    logger.error("‚ùå Could not detect supported framework.");
    return;
  }

  logger.success(`üì¶ Detected framework: ${framework}`);

  const dockerfilePath = path.join(projectPath, "Dockerfile");
  if (fs.existsSync(dockerfilePath)) {
    logger.warn("‚ö†Ô∏è  Dockerfile already exists. Use --force to overwrite.");
    return;
  }

 
  let content = null;
  const spinnerId = "docker-gen";

  if (useAI) {
    logger.startSpinner(spinnerId, "Generating Dockerfile using Gemini AI...");
    content = await generateDockerfile(framework);
    if (content) {
      logger.succeedSpinner(spinnerId, "‚úÖ Dockerfile generated by Gemini AI");
    } else {
      logger.failSpinner(spinnerId, "‚ùå Failed to generate with AI. Using fallback...");
    }
  }

  if (content) {
    await fs.writeFile(dockerfilePath, content);
    logger.fileOperation("create", dockerfilePath);
  } else {
    console.log(chalk.yellow("üõ† Falling back to EJS template..."));
    await fallbackFromTemplate(framework, projectPath);
  }
};

export default analyzeProject;
